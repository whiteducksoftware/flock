#####################
# examples/01_introduction/01_simple_example.py
#####################
"""
Title: Building Your First Flock Agent

In this example, we'll walk you through creating and running a simple Flock system with a single agent.
Flock enables you to build LLM-powered agents by simply declaring what data each agent receives and what it
produces—no more tedious prompt engineering!

What you'll learn:
  - How to set up the Flock model (using litellm; check out https://docs.litellm.ai/docs/providers for valid model IDs).
  - How to create a Flock instance that serves as the central orchestrator and context holder.
  - How to define a simple agent (named "bloggy") by declaring its input and output.
  - How to add the agent to your Flock.
  - How to run the agent workflow asynchronously in local debug mode (without needing Temporal).

The "bloggy" agent in this example is designed to take a blog idea as input and generate a funny blog title
along with a list of blog headers as output.

Let's get started!
"""

import asyncio

from flock.core.flock import Flock
from flock.core.flock_agent import FlockAgent


# --------------------------------
# Define the model
# --------------------------------
# Flock uses litellm to talk to LLMs
# Please consult the litellm documentation for valid IDs:
# https://docs.litellm.ai/docs/providers
MODEL = "openai/gpt-4o"

async def main():
    # --------------------------------
    # Create the flock and context
    # --------------------------------
    # The flock is the place where all the agents are at home
    # set local_debug to True to run the flock without Temporal
    # Check out the examples in /temporal to learn about Temporal
    flock = Flock(model=MODEL, local_debug=True)

    # --------------------------------
    # Create an agent
    # --------------------------------
    # The Flock doesn't believe in prompts (see the readme for more info)
    # The Flock just declares what agents get in and what agents produce
    # bloggy takes in a blog_idea and outputs a funny_blog_title 
    # and blog_headers
    bloggy = FlockAgent(
        name="bloggy", 
        input="blog_idea", 
        output="funny_blog_title, blog_headers"
    )
    flock.add_agent(bloggy)

    # --------------------------------
    # Run the flock
    # --------------------------------
    # Tell the flock who is the starting and what input to give it
    await flock.run_async(
        start_agent=bloggy, 
        input={"blog_idea": "A blog about cats"}
    )

if __name__ == "__main__":
    asyncio.run(main())

#####################
# examples/01_introduction/02_typed_output.py
#####################
"""
Title: Advanced Flock Agent with Caching, Type Hints, and Tool Integration

In this example, we'll show you how to build a more advanced Flock system that:
  - Uses a custom output formatter (RichTables) for a polished, swaggy display.
  - Defines output types using standard Python type hints (including lists and Literals) for structured results.
  - Integrates external tools (like a web content scraper) so that agents can perform more complex operations.
  - Leverages caching so that if an agent is called with the same input, the cached result is returned—this is particularly
    useful for expensive operations such as web scraping or during debugging.

The agent in this example takes a URL as input and outputs:
  - A title,
  - A list of headings,
  - A list of dictionaries mapping entities to metadata, and
  - A type (limited to one of 'news', 'blog', 'opinion piece', or 'tweet').

After executing the agent, you can work with the result as a real Python object that respects the defined types.

Let's dive in!
"""

import asyncio
from pprint import pprint

from flock.core.flock import Flock
from flock.core.flock_agent import FlockAgent
from flock.core.logging.formatters.base_formatter import FormatterOptions
from flock.core.logging.formatters.rich_formatters import RichTables
from flock.core.logging.formatters.themed_formatter import ThemedAgentResultFormatter
from flock.core.tools import basic_tools

async def main():
    # --------------------------------
    # Create the flock
    # --------------------------------
    # Some people need some swag in their output
    # See the formatting examples
    format_options = FormatterOptions(RichTables)
    flock = Flock(local_debug=True, output_formatter=format_options)


    # --------------------------------
    # Create an agent
    # --------------------------------
    # Some additions to example 01
    # - you can define the output types of the agent with standart python type hints
    # - you can define the tools the agent can use
    # - you can define if the agent should use the cache 
    #   results will get cached and if true and if the input is the same as before, the agent will return the cached result
    #   this is useful for expensive operations like web scraping and for debugging
    agent = FlockAgent(
        name="my_agent",
        input="url",
        output="title, headings: list[str], entities_and_metadata: list[dict[str, str]], type:Literal['news', 'blog', 'opinion piece', 'tweet']",
        tools=[basic_tools.get_web_content_as_markdown],
        use_cache=True,
    )
    flock.add_agent(agent)


    # --------------------------------
    # Run the agent
    # --------------------------------
    # ATTENTION: Big table incoming
    # It's worth it tho!
    result = await flock.run_async(
        start_agent=agent,
        input={"url": "https://lite.cnn.com/travel/alexander-the-great-macedon-persian-empire-darius/index.html"},
    )

    # --------------------------------
    # The result type
    # --------------------------------
    # Btw, the result is a real python object with the types you defined
    # so this works:
    pprint(result.title)



if __name__ == "__main__":
    asyncio.run(main())

#####################
# examples/01_introduction/03_tool_and_code_agent.py
#####################
"""
Title: Celebrity Age Calculator with Themed Output and Tool Integration

In this example, you'll see an advanced Flock agent in action. This agent demonstrates several cool features:
  - **Themed Output:** We use ThemedAgentResultFormatter with a custom theme (e.g. "adventuretime")
    to spice up the CLI output.
  - **Tool Integration:** The agent is configured with multiple tools, so it can, for example,
    use web search and code evaluation to calculate some advanced maths.
  - **Caching:** Enabled caching ensures that if you run the agent with the same input,
    it will return a cached result—ideal for expensive operations or rapid testing.
  - **Simple Declaration:** Just like all Flock agents, this one declares what it needs ("a_person")
    and what it produces ("persons_age_in_days"), without the hassle of prompt engineering.

In this scenario, our agent ("my_celebrity_age_agent") takes a person's name as input and returns
that person's age in days. We then use it to calculate Johnny Depp's age in days. Very advanced maths!

Let's see how it's done!
"""

import asyncio

from devtools import debug


from flock.core.flock import Flock
from flock.core.flock_agent import FlockAgent
from flock.core.logging.formatters.base_formatter import FormatterOptions
from flock.core.logging.formatters.rich_formatters import RichTables
from flock.core.logging.formatters.themed_formatter import ThemedAgentResultFormatter
from flock.core.tools import basic_tools

MODEL = "openai/gpt-4o"

async def main():
    # --------------------------------
    # Create the flock
    # --------------------------------
    # In case the table of example 02 wasn't fancy enough
    # The author had over 300 cli themes lying around....
    format_options = FormatterOptions(ThemedAgentResultFormatter, wait_for_input=False, settings={"theme": "adventuretime"})
    flock = Flock(local_debug=True, output_formatter=format_options)


    # --------------------------------
    # Tools
    # --------------------------------
    # Let's talk abou tools
    # DeclarativeAgent has a tools argument that takes in ANY callable
    # like the ones in flock.core.tools.basic_tools
    # or your own custom tools
    agent = FlockAgent(
        name="my_celebrity_age_agent",
        input="a_person",
        output="persons_age_in_days",
        tools=[basic_tools.web_search_duckduckgo, basic_tools.code_eval],
        use_cache=True,
    )
    flock.add_agent(agent)

    # --------------------------------
    # Run the agent
    # --------------------------------
    # Let's calculate Johnny Depp's age in days
    await flock.run_async(
        start_agent=agent,
        input={"a_person": "Johnny Depp"},
    )


if __name__ == "__main__":
    asyncio.run(main())

#####################
# examples/01_introduction/04_descriptions.py
#####################
"""
Title: Getting into the details with descriptions

Perhaps your co-worker who loves writing blog post long prompts for his agents thought he has found an out:
"Due to my long prompts I can make my agents do anything I want, which is not possible with your little declarative flocky!" he proclaimed.
"What do you do when you need your agents to handle edge cases?" he asked. 

You, being the flocky expert, decided to show him how to use 'descriptions' to make your agents do anything his agents can do and more.
"""

import asyncio

from flock.core.flock import Flock
from flock.core.flock_agent import FlockAgent


MODEL = "openai/gpt-4o"

async def main():
 
    flock = Flock(model=MODEL, local_debug=True)

    # --------------------------------
    # Add descriptions
    # --------------------------------
    # If you NEED your agent to handle edge cases, you can add descriptions to your agents
    # The desctiption property on the FlockAgent class allows you to add a description to your agent,
    # while with "|" you can specify descriptions of the input and output fields of the agent.
    a_cat_name_agent = FlockAgent(
        name="name_agent", 
        description="Creates five ideas for cute pet names but only for cats and will reject any other animals.",
        input="animal | the animal to create a cute name for", 
        output="""
            cute_name: list[str] | a list of 5 cute names IN ALL CAPS, 
            error_message | an error message if the input is not a cat
        """
    )
    flock.add_agent(a_cat_name_agent)

  
    await flock.run_async(
        start_agent=a_cat_name_agent, 
        input={"animal": "My new dog"}
    )

if __name__ == "__main__":
    asyncio.run(main())

#####################
# examples/01_introduction/05_typed_output2.py
#####################
"""
Title: Random User List Generator with Data Class Integration and Caching

In this example, you'll see a simple Flock agent in action that generates a list of random users.
This example demonstrates several cool features:
  - **Data Class Integration:** We define a `RandomPerson` dataclass to structure the random user data.
  - **Caching:** Enabled caching ensures that if you run the agent with the same input,
    it will return a cached result—ideal for speeding up repeated requests.
  - **Simple Agent Declaration:** Like all Flock agents, this one declares what it needs 
    ("amount_of_people") and what it produces ("random_user_list: list[RandomPerson]") 
    without the hassle of prompt engineering.

In this scenario, our agent ("people_agent") takes the number of people to generate as input,
and returns a list of randomly generated users. We then print the number of generated users.
Let's see how it's done!
"""

import asyncio
from dataclasses import dataclass
from pprint import pprint
from typing import Literal

from flock.core.flock import Flock
from flock.core.flock_agent import FlockAgent
from flock.core.logging.formatters.base_formatter import FormatterOptions
from flock.core.logging.formatters.rich_formatters import RichTables
from flock.core.logging.formatters.themed_formatter import ThemedAgentResultFormatter
from flock.core.tools import basic_tools

# --------------------------------
# Define the data model for a random person
# --------------------------------
@dataclass
class RandomPerson:
    name: str
    age: int
    gender: Literal["female", "male"]
    job: str
    favorite_movie: str  
    short_bio: str

RandomUserList = list[RandomPerson]

async def main():
   
    flock = Flock(local_debug=True)

    # --------------------------------
    # Define the Random User List Agent
    # --------------------------------
    # This agent ("people_agent") is responsible for generating a list of random users.
    # It requires the input "amount_of_people" and produces an output "random_user_list" 
    # which is a list of RandomPerson objects.
    # Caching is enabled so that repeated requests with the same input can return a cached result.
    people_agent = FlockAgent(
        name="people_agent",
        input="amount_of_people",
        output="random_user_list: RandomUserList",
        use_cache=True,
    )
    flock.add_agent(people_agent)

    # --------------------------------
    # Run the agent to generate random users
    # --------------------------------
    # We execute the agent asynchronously, passing in the desired amount of people.
    # The result is a namespace containing the generated random user list.
    result = await flock.run_async(
        start_agent=people_agent,
        input={"amount_of_people": "10"},
    )

    # --------------------------------
    # Process and display the result
    # --------------------------------
    # Here we print the number of users generated to verify our agent's output.
    pprint(len(result.random_user_list))

if __name__ == "__main__":
    # Run the main coroutine using asyncio
    asyncio.run(main())

#####################
# examples/01_introduction/06_simple_hand_off.py
#####################
"""
Title: Simple hand-off between two agents

In this example, we create a simple two-agent chain:
    1. IdeaAgent: Receives a query and outputs a fun software project idea.
    2. ProjectPlanAgent: Takes the software project idea and outputs a catchy project name, project pitch, tech stack, and project implementation plan.

The IdeaAgent is the starting point of the workflow, and it hands off the software project idea to the ProjectPlanAgent.
The ProjectPlanAgent then generates additional project details based on the idea.

A more in-depth example of agent hand-off is available in the "a_hand_off_pm.py" example.

To make hand offs between agents as intuitive as possible an agent handoff works by these easy to remember rules:

1. Connect agents by setting the `hand_off` attribute of the first agent to the second agent.
idea_agent.hand_off = project_plan_agent

2. set the input of the second agent to the output of the first agent (or parts of it).
idea_agent -> a_fun_software_project_idea -> project_plan_agent

That's it! The agents are now connected and will pass data between them as expected.

For 99% of use cases, this is all you need to do to create a hand-off between agents.

In later examples, we will explore more advanced hand-off scenarios and fall back rules.
"""

import asyncio

from flock.core.flock import Flock
from flock.core.flock_agent import FlockAgent
from flock.core.logging.formatters.base_formatter import FormatterOptions
from flock.core.logging.formatters.rich_formatters import RichTables


async def main():

    flock = Flock(local_debug=True, output_formatter=
                    FormatterOptions(formatter=RichTables, 
                                   wait_for_input=True, 
                                   settings={}),
                    enable_logging=True)
    
    idea_agent = FlockAgent(
        name="idea_agent",
        input="query",
        output="a_fun_software_project_idea",
        use_cache=True,
    )

    project_plan_agent = FlockAgent(
        name="project_plan_agent",
        input="a_fun_software_project_idea",
        output="catchy_project_name, project_pitch, techstack, project_implementation_plan",
        use_cache=True,
    )
    
    idea_agent.hand_off = project_plan_agent

    flock.add_agent(idea_agent)
    flock.add_agent(project_plan_agent)

    await flock.run_async(
        input={"query": "fun software project idea"},
        start_agent=idea_agent,
    )


if __name__ == "__main__":
    asyncio.run(main())
#####################
# examples/02_cook_book/flock_without_llms.py
#####################
"""
Tutorial Example: Creating a agent chain, without agents

also called state machine

In this example, we create a simple two-agent chain:
  1. DoublerAgent: Receives a number ("value") and outputs its double ("doubled").
  2. AdderAgent: Takes the "doubled" value from the previous agent and adds 5 to produce "result".

The special thing about this example is that we don't use any external tools or LLMs.
Instead, we create a simple chain of agents that pass data between each other.

"""

import asyncio
from flock.core.flock import Flock
from flock.core.flock_agent import FlockAgent

# Define a simple agent that doubles the input value.
class DoublerAgent(FlockAgent):
    async def evaluate(self, inputs: dict[str, any]) -> dict[str, any]:
        # Retrieve the input value (defaulting to 0 if not provided)
        value = inputs.get("value", 0)
        # Return the doubled value
        return {"doubled": value * 2}

# Define another agent that adds 5 to the doubled value.
class AdderAgent(FlockAgent):
    async def evaluate(self, inputs: dict[str, any]) -> dict[str, any]:
        # Retrieve the "doubled" value (defaulting to 0 if not provided)
        doubled = inputs.get("doubled", 0)
        # Return the final result after adding 5
        return {"result": doubled + 5}

async def main():
    # --------------------------------
    # Create the flock
    # --------------------------------
    # Create a Flock instance in local debug mode (no Temporal needed for this simple demo)
    flock = Flock(local_debug=True)

    # --------------------------------
    # Create the agents
    # --------------------------------
    # Define the doubler agent:
    doubler = DoublerAgent(
        name="doubler_agent",
        input="value: int | The number to double",
        output="doubled: int | The doubled value",
    )

    # Define the adder agent:
    adder = AdderAgent(
        name="adder_agent",
        input="doubled: int | The doubled value from the previous agent",
        output="result: int | The final result after adding 5",
    )

    # --------------------------------
    # Set up hand-off
    # --------------------------------
    # Link the agents so that the output of doubler is passed to adder automatically.
    doubler.hand_off = adder

    # Register both agents with the flock.
    flock.add_agent(doubler)
    flock.add_agent(adder)

    # --------------------------------
    # Run the agent chain
    # --------------------------------
    # Start the workflow with the doubler agent and provide the initial input.
    result = await flock.run_async(start_agent=doubler, input={"value": 10})
    
    # Print the final result. Expected output: result should be (10*2)+5 = 25.
    print(result)

if __name__ == "__main__":
    asyncio.run(main())

#####################
# examples/02_cook_book/long_research_no_handoff.py
#####################
"""
Title: Building huge documents without a hand off

In this example, we'll outline a thorough overview of a topic and then draft the content for each section.

We do this without using an explicit handoff between the outline and draft agents, but by using flock itself to manage the flow.

This way you can build create workflows that need a transformation of data from one agent to another without the need for a handoff.

This example implements https://dspy.ai/#__tabbed_2_6 to also highlight the ability to build dspy pipelines with flock.
"""


import asyncio

from flock.core.flock import Flock
from flock.core.flock_agent import FlockAgent
from flock.core.logging.formatters.base_formatter import FormatterOptions
from flock.core.logging.formatters.rich_formatters import RichTables
from flock.core.tools import basic_tools


async def main():

    flock = Flock(local_debug=True, output_formatter=FormatterOptions(formatter=RichTables, settings={}),enable_logging=True)
    
    outline_agent = FlockAgent(
        name="outline_agent",
        description="Outline a thorough overview of a topic.",
        input="topic",
        output="title,sections: list[str],section_subheadings: dict[str, list[str]]|mapping from section headings to subheadings",
        tools=[basic_tools.web_search_tavily],
    )


    draft_agent = FlockAgent(
        name="draft_agent",
        input="flock.topic,flock.section_heading,flock.section_subheadings: list[str]",
        output="content|markdown-formatted section",
        tools=[basic_tools.web_search_tavily],
    )

     
    flock.add_agent(outline_agent)
    flock.add_agent(draft_agent)

    # Instead defining handoff between agents, we just use flock to run the outline agent
    result = await flock.run_async(
        start_agent=outline_agent,
    )

    sections =[]
    # We then do our processing (in this case formatting the content) and run the draft agent for each section
    for heading, subheadings in result.section_subheadings.items():
            section, subheadings = f"## {heading}", [f"### {subheading}" for subheading in subheadings]
            result_content = await flock.run_async(
                input={"topic": result.topic,
                       "section_heading": section,
                       "section_subheadings": subheadings
                       },
                start_agent=draft_agent,
            )
            sections.append(result_content.content)
            with open("output.md", "w") as f:
                f.write("\n\n".join(sections))





if __name__ == "__main__":
    asyncio.run(main())
#####################
# examples/02_cook_book/project_manager.py
#####################
"""
Tutorial Example: Multi-Agent Chain for Software Project Scaffolding

In this example, we build a chain of Flock agents that collaborate to scaffold a software project.
The workflow is as follows:

  1. **idea_agent:**  
     Takes a simple query and returns a fun software project idea.

  2. **project_plan_agent:**  
     Uses the software project idea to generate additional project details such as:
       - A catchy project name
       - A project pitch
       - A recommended tech stack
       - A project implementation plan

  3. **readme_agent:**  
     Consumes the outputs of the project_plan_agent to produce a readme file.

  4. **issue_agent:**  
     Uses the readme and additional project details to create GitHub issues and files.

Each agent is declared using a simple input/output signature, and the chain is established via the `hand_off` property.
Flock manages the registration and execution of agents. In this example, we run the workflow in local debug mode.

Let's see how it all comes together!
"""



import asyncio
from dataclasses import dataclass


from flock.core.flock import Flock
from flock.core.flock_agent import FlockAgent
from flock.core.logging.formatters.base_formatter import FormatterOptions
from flock.core.logging.formatters.rich_formatters import RichTables
from flock.core.tools import basic_tools
from flock.core.tools.dev_tools import github


@dataclass
class Features:
    title: str
    description: str
    acceptance_criteria: str


async def main():

    flock = Flock(local_debug=True, output_formatter=FormatterOptions(formatter=RichTables, wait_for_input=False, settings={}),enable_logging=True)
    
    idea_agent = FlockAgent(
        name="idea_agent",
        input="query",
        output="software_project_idea",
        tools=[basic_tools.web_search_tavily],
        use_cache=True,
    )

    project_plan_agent = FlockAgent(
        name="project_plan_agent",
        input="software_project_idea",
        output="catchy_project_name, project_pitch, techstack, project_implementation_plan",
        tools=[basic_tools.web_search_tavily],
        use_cache=True,
    )

    readme_agent = FlockAgent(
        name="readme_agent",
        input="catchy_project_name, project_pitch, techstack, project_implementation_plan",
        output="readme",
        tools=[github.upload_readme],
        use_cache=True,
    )   

    feature_agent = FlockAgent(
        name="feature_agent",
        input="readme, catchy_project_name, project_pitch, techstack, project_implementation_plan",
        output="features : list[Features]",
        tools=[github.create_user_stories_as_github_issue, github.create_files],
        use_cache=True,
    )   

    issue_agent = FlockAgent(
        name="issue_agent",
        input="current_feature, readme, techstack, project_implementation_plan, all_feature_titles",
        output="user_stories_on_github, files_on_github",
        tools=[github.create_user_stories_as_github_issue, github.create_files],
        use_cache=True,
    )   

    idea_agent.hand_off = project_plan_agent
    project_plan_agent.hand_off = readme_agent
    readme_agent.hand_off = feature_agent


    flock.add_agent(idea_agent)
    flock.add_agent(project_plan_agent)
    flock.add_agent(readme_agent)
    flock.add_agent(feature_agent)
    flock.add_agent(issue_agent)

    features : Features = await flock.run_async(
        start_agent=idea_agent,
    )



if __name__ == "__main__":
    asyncio.run(main())
#####################
# examples/02_cook_book/self_improvement.py
#####################
"""
Title: Reasoning assistant with self managed memory
"""

from datetime import datetime
import warnings

from flock.core.tools import basic_tools
warnings.simplefilter("error", UserWarning)
import asyncio
from dataclasses import dataclass, field

from flock.core.flock import Flock
from flock.core.flock_agent import FlockAgent, FlockAgentConfig, HandOff

from rich.prompt import Prompt
from rich.panel import Panel
from rich.console import Console


@dataclass
class Chat:
    chat_history: list[str] = field(default_factory=list)
    user_query: str = ""
    answer_to_query: str = ""
    memory: str = ""
    
    async def before_response(self, agent, inputs):
        console = Console()
        # Load the memory from file (if it exists)
        try:
            with open("memory.txt", "r") as file:
                self.memory = file.read()
        except FileNotFoundError:
            self.memory = ""

        # Use a Rich-styled prompt to get user input
        self.user_query = Prompt.ask("[bold cyan]User[/bold cyan]")
        inputs["user_query"] = self.user_query
        inputs["chat_history"] = self.chat_history
        inputs["memory"] = self.memory

    # Triggers after the agent responds to the user query
    async def after_response(self, agent, inputs, outputs):
        # Update answer and history based on the agent's outputs
        console = Console()
        self.answer_to_query = outputs["answer_to_query"]
        self.chat_history.append({"user": self.user_query, "assistant": self.answer_to_query})
        self.memory += outputs.get("important_new_knowledge_to_add_to_memory", "") + "\n"

        # Save updated memory to file
        with open("memory.txt", "w") as file:
            file.write(self.memory)

        # Display the assistant's reasoning (if available) in a styled panel
        reasoning = outputs.get("reasoning", "")
        if reasoning:
            reasoning_panel = Panel(
                reasoning,
                title="[bold blue]Assistant Reasoning[/bold blue]",
                border_style="blue",
            )
            console.print(reasoning_panel)

        # Display the assistant's answer in a styled panel
        answer_panel = Panel(
            self.answer_to_query,
            title="[bold green]Assistant Answer[/bold green]",
            border_style="green",
        )
        console.print(answer_panel)

    # Triggers at handoff to the next agent
    def hand_off(self, context, result):
        if self.user_query.lower() == "goodbye":
            return None
        return HandOff(next_agent="chatty")


MODEL = "openai/gpt-4o"

async def main():

    chat_helper = Chat()
    flock = Flock(model=MODEL, local_debug=True)


    chatty = FlockAgent(
        name="chatty", 
        description=f"You are Chatty, a friendly assistant that loves to chat. Today is {datetime.now().strftime('%A, %B %d, %Y')}",
        input="user_query, memory | Memory of previous interactions, chat_history | the current chat history", 
        output="answer_to_query, important_new_knowledge_to_add_to_memory | Empty string if no knowledge to add",
        initialize_callback=chat_helper.before_response,
        terminate_callback=chat_helper.after_response,
        config=FlockAgentConfig(disable_output=True),
        tools=[basic_tools.web_search_tavily],
    )
    flock.add_agent(chatty)

    chatty.hand_off = chat_helper.hand_off
   
    await flock.run_async(
        start_agent=chatty, 
        input={"memory": "","user_query": "","chat_history": ""}
    )


if __name__ == "__main__":
    asyncio.run(main())

#####################
# examples/03_misc_wip/formatting/01_pretty_print.py
#####################
import asyncio

from flock.agents import DeclarativeAgent
from flock.core.flock import Flock
from flock.core.logging.formatters.base_formatter import FormatterOptions
from flock.core.logging.formatters.pprint_formatter import PrettyPrintFormatter
from flock.core.logging.formatters.themed_formatter import ThemedAgentResultFormatter

MODEL = "openai/gpt-4o"

async def main():
    # --------------------------------
    # Formatting and themes
    # --------------------------------
    # Some people need a little more color in their life
    # Flock support themes and formatting options for the output
    # Pretty print is a simple formatter that displays the results as a dictionary
    # Pretty print is the default formatter
    format_options = FormatterOptions(PrettyPrintFormatter)
    flock = Flock(model=MODEL, local_debug=True, output_formatter=format_options)


    bloggy = DeclarativeAgent(name="bloggy", input="blog_idea", output="funny_blog_title, blog_headers")
    flock.add_agent(bloggy)
    await flock.run_async(start_agent=bloggy, input="a blog about cats")


if __name__ == "__main__":
    asyncio.run(main())

#####################
# examples/03_misc_wip/formatting/02_rích_table.py
#####################
import asyncio

from flock.agents import DeclarativeAgent
from flock.core.flock import Flock
from flock.core.logging.formatters.base_formatter import FormatterOptions
from flock.core.logging.formatters.pprint_formatter import PrettyPrintFormatter
from flock.core.logging.formatters.rich_formatters import RichTables
from flock.core.logging.formatters.themed_formatter import ThemedAgentResultFormatter

MODEL = "openai/gpt-4o"

async def main():
    # --------------------------------
    # Formatting and themes
    # --------------------------------
    # Some people need a little more color in their life
    # Flock support themes and formatting options for the output
    # RichAgentResultFormatter uses the Rich library to display the results in a table
    format_options = FormatterOptions(RichTables,True)
    flock = Flock(model=MODEL, local_debug=True, output_formatter=format_options)


    bloggy = DeclarativeAgent(name="bloggy", input="blog_idea", output="funny_blog_title, blog_headers")
    flock.add_agent(bloggy)
    await flock.run_async(start_agent=bloggy, input="a blog about cats")


if __name__ == "__main__":
    asyncio.run(main())

#####################
# examples/03_misc_wip/formatting/03_themed_table.py
#####################
import asyncio
from pprint import pprint

from devtools import debug

from flock.agents.declarative_agent import DeclarativeAgent
from flock.core.flock import Flock
from flock.core.logging.formatters.base_formatter import FormatterOptions
from flock.core.logging.formatters.themed_formatter import ThemedAgentResultFormatter
from flock.core.logging.formatters.themed_formatter import ThemedAgentResultFormatter
from flock.core.tools import basic_tools

async def main():
    # --------------------------------
    # Formatting and themes
    # --------------------------------
    # Some people need a little more color in their life
    # Flock support themes and formatting options for the output
    # ThemedAgentResultFormatter uses actual CLI themes the author of Flock had lying around
    format_options = FormatterOptions(ThemedAgentResultFormatter, wait_for_input=True, settings={"theme": "adventure"})
    flock = Flock(local_debug=True, output_formatter=format_options)

    agent = DeclarativeAgent(
        name="my_agent",
        input="url",
        output="title, headings: list[str], entities_and_metadata: list[dict[str, str]], type:Literal['news', 'blog', 'opinion piece', 'tweet']",
        tools=[basic_tools.get_web_content_as_markdown],
    )
    flock.add_agent(agent)

    await flock.run_async(
        start_agent=agent,
        input="https://lite.cnn.com/travel/alexander-the-great-macedon-persian-empire-darius/index.html",
    )

 



if __name__ == "__main__":
    asyncio.run(main())

#####################
# examples/03_misc_wip/logging_examples/01_basic_logging.py
#####################
import asyncio

from flock.core.logging.handlers import live_update_handler, performance_handler
from flock.core.logging.logger import flock_logger


async def demo_logging():
    """Demonstrate various logging features."""
    # Basic logging with different levels
    flock_logger.info("Starting logging demonstration")
    flock_logger.debug("Debug information", details={"version": "1.0.0"})
    flock_logger.warning("This is a warning message")

    # Performance tracking
    with performance_handler.track_time("data_processing"):
        # Show progress tracking
        with live_update_handler.progress_tracker("Processing data") as update_progress:
            for i in range(5):
                await asyncio.sleep(0.5)  # Simulate work
                update_progress((i + 1) * 20)  # Update progress (20%, 40%, etc.)
                flock_logger.info(f"Processing step {i + 1}")
        performance_handler.display_timings()

    # Show status updates with live panels
    with live_update_handler.update_workflow_status(
        "demo-workflow", "Running", {"steps_completed": 3, "current_phase": "data analysis"}
    ):
        await asyncio.sleep(1)  # Simulate work
        flock_logger.info("Analyzing data...")

    # Track performance of another operation
    with performance_handler.track_time("final_processing"):
        # Show activity status
        with live_update_handler.update_activity_status(
            "activity-1", "Final Processing", "In Progress", {"items_processed": 100}
        ):
            await asyncio.sleep(0.5)  # Simulate work
            flock_logger.info("Finalizing results")

    # Display final performance metrics
    flock_logger.success("Demo completed successfully")
    performance_handler.display_timings()


async def main():
    """Run the logging demonstration."""
    try:
        await demo_logging()
    except Exception as e:
        flock_logger.error(f"Demo failed: {e}")
        raise


if __name__ == "__main__":
    asyncio.run(main())

#####################
# examples/03_misc_wip/logging_examples/02_temporal_logging.py
#####################
import asyncio
import uuid
from datetime import timedelta

from temporalio.client import Client, WorkflowIDReusePolicy
from temporalio.service import RPCError

from flock.core.flock_agent import FlockAgent
from flock.core.context.context import FlockContext
from flock.core.logging import flock_logger, live_update_handler, performance_handler


class TemporalLoggingAgent(FlockAgent):
    """Demo agent that showcases logging with Temporal integration."""

    async def run(self, context: FlockContext) -> dict:
        workflow_id = context.state.get("workflow_id", "temporal-demo")
        flock_logger.set_context(workflow_id=workflow_id)

        with performance_handler.track_time("agent_execution"):
            # Log agent startup
            flock_logger.info("Starting Temporal logging agent")
            flock_logger.debug("Context state", state=context.state)

            # Simulate work with progress tracking
            with live_update_handler.progress_tracker("Processing workflow data") as update_progress:
                for i in range(3):
                    with performance_handler.track_time(f"step_{i + 1}"):
                        await asyncio.sleep(0.5)  # Simulate work
                        update_progress((i + 1) * 33)
                        flock_logger.activity_event(f"Completed workflow step {i + 1}")

            # Show workflow status
            with live_update_handler.update_workflow_status(workflow_id, "Completing", {"steps_completed": 3}):
                await asyncio.sleep(0.5)  # Simulate final work
                flock_logger.success("Workflow execution completed")

        # Display performance metrics
        performance_handler.display_timings()
        return {"status": "success", "steps_completed": 3}


async def run_temporal_workflow(client: Client, workflow_id: str):
    """Run the workflow with proper logging."""
    # Create agent and context
    agent = TemporalLoggingAgent(name="temporal-logging-demo", model="demo-model")
    context = FlockContext()
    context.state["workflow_id"] = workflow_id
    context.state["current_agent"] = agent.name

    try:
        # Execute workflow
        with performance_handler.track_time("workflow_execution"):
            result = await client.execute_workflow(
                "FlockWorkflow.run",
                context.to_dict(),
                id=workflow_id,
                task_queue="default",
                execution_timeout=timedelta(minutes=5),
                id_reuse_policy=WorkflowIDReusePolicy.REJECT_DUPLICATE,  # Prevent duplicate workflows
            )

        flock_logger.success("Workflow completed", result=result)
        return result

    except Exception as e:
        flock_logger.error(f"Workflow failed: {e}")
        raise


async def main():
    """Run the Temporal logging demonstration."""
    # Generate a unique workflow ID
    workflow_id = f"temporal-logging-demo-{uuid.uuid4()}"

    try:
        # Attempt to connect to Temporal with a timeout
        flock_logger.info("Connecting to Temporal server...")
        try:
            async with asyncio.timeout(3.0):  # 3 second timeout
                client = await Client.connect("localhost:7233")
        except TimeoutError:
            raise RuntimeError("Connection attempt timed out")

        # If we get here, we successfully connected
        flock_logger.workflow_event("Starting Temporal workflow", workflow_id=workflow_id)
        await run_temporal_workflow(client, workflow_id)

    except (RPCError, RuntimeError) as e:
        if any(msg in str(e).lower() for msg in ["connection refused", "timed out"]):
            # Handle connection failure gracefully
            flock_logger.warning(
                "Could not connect to Temporal server. Make sure the server is running on localhost:7233"
            )
            # Demonstrate logging still works without Temporal
            flock_logger.info("Running agent locally instead...")
            agent = TemporalLoggingAgent(name="local-demo", model="demo-model")
            context = FlockContext()
            context.state["workflow_id"] = workflow_id
            await agent.run(context)
        else:
            # Let our error handler format other errors beautifully
            raise

    except Exception:
        # Let our error handler format this beautifully
        raise


if __name__ == "__main__":
    # The error handler is already installed via flock.core.logging import
    asyncio.run(main())

